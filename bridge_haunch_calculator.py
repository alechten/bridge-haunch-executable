# -*- coding: utf-8 -*-
"""bridge_haunch_calculator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cYNEzQubbTN3DitNrKazRbQHJbvrN7Aa
"""

import math
import numpy as np
import pandas as pd
from typing import Dict, List, Union, Optional
from dataclasses import dataclass, field

"""#INPUT

@dataclass
class HeaderInfo:
    structure_number: str = "S080 26369"
    route_name: str = "L-10B"
    feature_crossed: str = "I-80"
    designer_name: str = "AML"
    designer_date: str = "##/##/2025"
    reviewer_name: str = "TBD"
    reviewer_date: str = "TBD"
    logo_filepath: str = r"/content/NDOT/NDOT_logo.png"

@dataclass
class VerticalCurveData:
    sta_VPI: float = 11510
    elev_VPI: float = 2242.50
    grade_1: float = 4.9200
    grade_2: float = -5.1800
    L_v_curve: float = 845

@dataclass
class SubstructureData:
    sta_CL_sub: List[float] = field(default_factory=lambda: [11376, 11500, 11624])

@dataclass
class BridgeInfo:
    skew: float = 6 + 56/60
    turn_width: float = 3
    deck_width: float = 42
    rdwy_width: float = 40
    PGL_loc: float = 21  # deck_width / 2
    beam_spa: float = 8.75
    n_beams: int = 5
    rdwy_slope: float = 0.02
    deck_thick: float = 7.5
    sacrificial_ws: float = 0.5
    beam_shape: str = 'NU53'
    f_c_beam: float = 10
    f_c_i_beam: float = 7.5
    rail_shape: str = '39_SSCR'
    staged: str = 'yes'
    stage_start: str = 'left'
    stg_line_rt: float = 20  # PGL_loc - 1
    stg_line_lt: float = 16  # PGL_loc - 5
    ws: float = 0.035
    brg_thick: float = 1 / 12

@dataclass
class DebondConfig:
    row: int
    strands: List[int]
    lengths: List[float]

@dataclass
class HarpConfig:
    strands: List[int]
    harped_depths: List[float]
    harping_length_factor: float

@dataclass
class SpanConfig:
    straight_strands: List[int]
    strand_dist_bot: List[float]
    debond_config: List[DebondConfig]
    harp_config: HarpConfig

@dataclass
class BridgeInputs:
    header: HeaderInfo = field(default_factory=HeaderInfo)
    vertical_curve: VerticalCurveData = field(default_factory=VerticalCurveData)
    substructure: SubstructureData = field(default_factory=SubstructureData)
    bridge_info: BridgeInfo = field(default_factory=BridgeInfo)
    span_configs: List[SpanConfig] = field(default_factory=list)

    def __post_init__(self):
        # Set PGL_loc based on deck_width if not explicitly set
        if self.bridge_info.PGL_loc == 21 and self.bridge_info.deck_width != 42:
            self.bridge_info.PGL_loc = self.bridge_info.deck_width / 2

        # Set staging lines based on PGL_loc
        if self.bridge_info.stg_line_rt == 20:
            self.bridge_info.stg_line_rt = self.bridge_info.PGL_loc - 1
        if self.bridge_info.stg_line_lt == 16:
            self.bridge_info.stg_line_lt = self.bridge_info.PGL_loc - 5

    @property
    def num_spans(self) -> int:
        return len(self.substructure.sta_CL_sub) - 1

    def validate(self) -> List[str]:
        "Validate all input data and return list of error messages"
        errors = []

        # Basic validation
        if self.vertical_curve.L_v_curve <= 0:
            errors.append("Curve length must be positive")

        if len(self.substructure.sta_CL_sub) < 2:
            errors.append("At least 2 substructure stations required")

        # Check if stations are in ascending order
        stations = self.substructure.sta_CL_sub
        if not all(stations[i] <= stations[i+1] for i in range(len(stations)-1)):
            errors.append("Substructure stations must be in ascending order")

        # Bridge geometry validation
        if self.bridge_info.n_beams <= 0:
            errors.append("Number of beams must be positive")

        if self.bridge_info.beam_spa <= 0:
            errors.append("Beam spacing must be positive")

        # Span configuration validation
        if len(self.span_configs) != self.num_spans:
            errors.append(f"Number of span configurations ({len(self.span_configs)}) must match number of spans ({self.num_spans})")

        return errors

# Default span configuration for easy GUI initialization
def create_default_span_config() -> SpanConfig:
    return SpanConfig(
        straight_strands=[18, 18, 10, 0, 0, 0, 0],
        strand_dist_bot=[2, 4, 6, 8, 10, 12, 14],
        debond_config=[
            DebondConfig(row=1, strands=[6], lengths=[3]),
            DebondConfig(row=2, strands=[6], lengths=[6])
        ],
        harp_config=HarpConfig(
            strands=[2, 2, 2, 0, 0, 0, 0],
            harped_depths=[12, 10, 8, 0, 0, 0, 0],
            harping_length_factor=0.4
        )
    )

def create_default_inputs() -> BridgeInputs:
    "Create default input configuration"
    inputs = BridgeInputs()

    # Create span configs based on number of spans
    inputs.span_configs = [create_default_span_config() for _ in range(inputs.num_spans)]

    return inputs

#CALCULATE
"""

class VerticalCurve:
    def __init__(self, inputs: BridgeInputs): # Accept the inputs object
        self.v_c_data = inputs.vertical_curve # Store vertical_curve_data as an instance attribute

        self.sta_VPC = self.v_c_data.sta_VPI - self.v_c_data.L_v_curve / 2
        self.elev_VPC = self.v_c_data.elev_VPI - (self.v_c_data.grade_1 / 100) * (self.v_c_data.L_v_curve / 2)
        self.sta_VPT = self.v_c_data.sta_VPI + self.v_c_data.L_v_curve / 2
        self.elev_VPT = self.elev_VPC + self.v_c_data.grade_1 / 100 * self.v_c_data.L_v_curve + \
            (self.v_c_data.grade_2 - self.v_c_data.grade_1) / 200 / self.v_c_data.L_v_curve * (self.v_c_data.L_v_curve) ** 2

    def elev(self, sta):
        return np.where(sta < self.sta_VPC, self.elev_VPC - self.v_c_data.grade_1 / 100 * (self.sta_VPC - sta),\
                    np.where(sta > self.sta_VPT, self.elev_VPT + self.v_c_data.grade_2 / 100 * (sta - self.sta_VPT),\
                             self.elev_VPC + self.v_c_data.grade_1 / 100 * (sta - self.sta_VPC) + \
                              (self.v_c_data.grade_2 - self.v_c_data.grade_1) / 200 / self.v_c_data.L_v_curve * (sta - self.sta_VPC) ** 2))

class beam_rail_info:
    def __init__(self, inputs: BridgeInputs):
        beam_shape = inputs.bridge_info.beam_shape
        f_c_beam = inputs.bridge_info.f_c_beam
        f_c_i_beam = inputs.bridge_info.f_c_i_beam
        rail_shape = inputs.bridge_info.rail_shape
        n_beams = inputs.bridge_info.n_beams
        skew = inputs.bridge_info.skew

        self._beam_properties(beam_shape, f_c_beam, f_c_i_beam, n_beams, skew)
        self._rail_properties(rail_shape)

    def _beam_properties(self, beam_shape, f_c_beam, f_c_i_beam, n_beams, skew):
        beam_options = {
            'shape': ['NU35', 'NU43', 'NU53', 'NU63', 'NU70', 'NU78', 'IT13','IT17','IT21','IT25','IT29','IT33','IT39'],
            'height': [35.44, 43.31, 53.13, 63, 70.88, 78.75, 13.31, 17.25, 21.19, 25.13, 29.06, 33, 36.94],
            'area': [648.3, 695.1, 753.3, 812, 858.7, 905.5, 178.9, 204, 229.1, 254.2, 279.3, 304.4, 329.5],
            'y_b_nc': [16.13, 19.57, 23.95, 28.43, 32.05, 35.70, 4.5, 5.79, 7.22, 8.76, 10.37, 12.05, 13.77],
            'I_g_nc': [110218, 182262, 301949, 458653, 611646, 791107, 2034, 4472, 8334, 13871, 21300, 30837, 42688],
            'weight (8 ksi)': [0.711, 0.763, 0.827, 0.891, 0.942, 0.994, 0.196, 0.224, 0.251, 0.279, 0.306, 0.334, 0.362],
            'weight (10 ksi)': [0.72, 0.772, 0.837, 0.902, 0.954, 1.006, 0.199, 0.227, 0.255, 0.282, 0.310, 0.338, 0.366]
        }

        beam_df = pd.DataFrame(beam_options)
        beam_df.set_index('shape', inplace=True)

        self.b_height = beam_df.loc[beam_shape, 'height']
        self.area = beam_df.loc[beam_shape, 'area']
        self.y_b_nc = beam_df.loc[beam_shape, 'y_b_nc']
        self.I_g_nc = beam_df.loc[beam_shape, 'I_g_nc']
        self.is_NU = 'NU' in beam_shape
        self.is_IT = 'IT' in beam_shape

        if f_c_beam == 8:
            self.b_weight = beam_df.loc[beam_shape, 'weight (8 ksi)']
            self.E_c_i = 120000 * 0.975 * 0.15 ** 2 * f_c_i_beam ** 0.33
            self.E_c = 120000 * 0.975 * 0.15 ** 2 * f_c_beam ** 0.33
        elif f_c_beam == 10:
            self.b_weight = beam_df.loc[beam_shape, 'weight (10 ksi)']
            self.E_c_i = 120000 * 0.975 * 0.15 ** 2 * f_c_i_beam ** 0.33 # Corrected E_c_i calculation
            self.E_c = 120000 * 0.975 * 0.15 ** 2 * f_c_beam ** 0.33
        else:
            raise ValueError(f"Unsupported f_c_beam value: {f_c_beam}")

        if self.is_NU:
            self.tf_width = 48.25 / 12
            self.no_long_lines = 2 * n_beams
        elif self.is_IT:
            self.tf_width = 4.875 / 12
            self.no_long_lines = n_beams
        else:
            raise ValueError("Unsupported beam shape")

        self.flng_adjust_skew = self.tf_width / 2 * np.tan(np.deg2rad(skew))
        return self

    def _rail_properties(self, rail_shape):
        railing = {
          'shape': ['39_SSCR', '39_OCR', '42_NU_O', '42_NU_C', '42_NU_M', '34_NU_O', '34_NU_C','29_NE_O','29_NE_C','32_NJ','42_NJ'],
          'weight': [   0.365,    0.438,     0.441,     0.524,     0.873,     0.373,     0.455,    0.270,    0.382,  0.345,  0.413],
          'height': [      39,       39,        42,        42,        42,        34,        34,       29,       29,     32,     42],
          'bottom width': [10,       10,      10.5,      10.5,      10.5,      10.5,      10.5,       11,       11,     16,     16],
          'edge distance': [2,        2,         2,         2,         2,         2,         2,        1,        1,      0,      0]
        }

        rail_df = pd.DataFrame(railing)
        rail_df.set_index('shape', inplace=True)

        self.r_weight = rail_df.loc[rail_shape, 'weight']
        self.r_height = rail_df.loc[rail_shape, 'height']
        self.bottom_width = rail_df.loc[rail_shape, 'bottom width']
        self.edge_distance = rail_df.loc[rail_shape, 'edge distance']
        self.is_Open = 'O' in rail_shape
        return self

class beam_layout:
    def __init__(self, inputs: BridgeInputs, beam_rail_obj):
        PGL_loc = inputs.bridge_info.PGL_loc
        n_beams = inputs.bridge_info.n_beams
        beam_spa = inputs.bridge_info.beam_spa
        deck_width = inputs.bridge_info.deck_width
        sta_CL_sub = inputs.substructure.sta_CL_sub
        "New Values"
        self.span = np.zeros(len(sta_CL_sub) - 1)
        for i in range(len(sta_CL_sub) - 1):
            self.span[i] = sta_CL_sub[i+1] - sta_CL_sub[i]
        self.ns = len(sta_CL_sub) - 1
        self.offsets = np.zeros((1, beam_rail_obj.no_long_lines))
        self.off = np.zeros((1, beam_rail_obj.no_long_lines))
        self.cant_len = (deck_width - (n_beams - 1) * beam_spa) / 2
        self.beam_pos = self.cant_len + beam_spa * np.arange(n_beams)
        for i in range(n_beams):
            j, k = 2 * i, 2 * i + 1
            self.off[0,j] = PGL_loc - i * beam_spa - self.cant_len
            self.off[0,k] = PGL_loc - i * beam_spa - self.cant_len
            self.offsets[0,j] = self.off[0,j] - beam_rail_obj.tf_width / 2
            self.offsets[0,k] = self.off[0,k] + beam_rail_obj.tf_width / 2
        self.L_brg_brg = np.zeros(self.ns)
        for i in range(self.ns):
            if self.ns == 1:
                self.L_brg_brg = self.span
            else:
                if (i == 0) | (i == len(self.span) - 1):
                    self.L_brg_brg[i] = self.span[i] + 0.5 - 4 / 12 - 0.5 * 2
                else:
                    self.L_brg_brg[i] = self.span[i] - 2 * 4 / 12 - 0.5 * 2
        self.L_beam = self.L_brg_brg + 0.5 * 2

class stations_locations:
    def __init__(self, inputs: BridgeInputs, beam_layout_obj, beam_rail_obj):
        turn_width = inputs.bridge_info.turn_width
        skew = inputs.bridge_info.skew
        sta_CL_sub = inputs.substructure.sta_CL_sub
        ns = beam_layout_obj.ns
        L_brg_brg = beam_layout_obj.L_brg_brg
        off = beam_layout_obj.off
        abut_end = 0.5 * np.cos(np.deg2rad(skew))
        turn_end = turn_width / 2 * np.cos(np.deg2rad(skew))

        self.s = np.zeros(ns)
        #### IF 1 SPAN BRIDGE OR FIRST SPAN OF MULTISPAN USE ABUT END ####
        start_vals = np.where((ns == 1) | (np.arange(ns) == 0), abut_end, turn_end) + beam_rail_obj.flng_adjust_skew
        #### IF 1 SPAN BRIDGE OR LAST SPAN OF MULTISPAN USE ABUT END ####
        end_vals = np.where((ns == 1) | (np.arange(ns) == ns - 1), abut_end, turn_end) + beam_rail_obj.flng_adjust_skew
        L_eff = L_brg_brg - start_vals - end_vals
        #### GET NUMBER OF 10 FT POINTS FOR HALF SPAN THEN DOUBLE THEN ADD 3 FOR BRGS AND MIDPOINT ####
        self.s = np.ceil(L_eff / 20) * 2 + 3

        self.sta_x_10_ft = np.zeros((int(self.s.sum()), 1))
        g = 0
        for i in range(ns):
            h = (int(self.s[i]) - 3) / 2
            #### DEFINE ARRAY OF OUTPUTS FOR ONE SPAN ####
            #### ELSE SELECTS THE ARRAY BASED ON THE SPAN WITHIN THE NO. OF SPANS ####
            span_offsets = [(0, 0, abut_end, abut_end)] if ns == 1\
            else [(0, 10 / 12, abut_end, turn_end), (10 / 12, 10 / 12, turn_end, turn_end), (10 / 12, 0, turn_end, abut_end)][min(i, 2) if i != ns - 1 else 2]
            start_brg_off, end_brg_off, start, end = span_offsets
            m = sta_CL_sub[i] + start_brg_off + L_brg_brg[i] / 2 - h * 10
            #### INDEX VALUES BETWEEN START AND END OF SPAN ####
            j_vals = np.arange(int(self.s[i]))
            self.sta_x_10_ft[g:g + len(j_vals)] = np.where(j_vals == 0, sta_CL_sub[i] + start_brg_off,
                                   np.where(j_vals == 1, sta_CL_sub[i] + start + beam_rail_obj.flng_adjust_skew,
                                   np.where(j_vals < self.s[i] - 2, m + 10 * (j_vals - 1),
                                   np.where(j_vals == self.s[i] - 2, sta_CL_sub[i + 1] - end - beam_rail_obj.flng_adjust_skew,
                                           sta_CL_sub[i + 1] - end_brg_off)))).reshape(-1, 1)
            g += len(j_vals)
        self.sta_G = self.sta_x_10_ft + off * np.tan(np.deg2rad(skew))

        #### ARRAY OF THE PROGRESSIVE NUMBER OF X POINTS ACROSS SPANS ####
        indices = np.concatenate([[0], self.s.cumsum().astype(int)])
        #### MASKS RETURNS TRUE FOR STATIONS IN GIVEN SPAN ####
        masks = [(self.sta_G >= self.sta_G[indices[i]]) & (self.sta_G <= self.sta_G[indices[i+1]-1]) for i in range(ns)]
        #### SUM ARRAY FOR EACH SPAN OF STATION DISTANCES FROM FIRST STAION ####
        self.L_span_gen = sum(np.where(mask, self.sta_G - self.sta_G[indices[i]], 0) for i, mask in enumerate(masks))

class section_properties_dead_loads:
    def __init__(self, inputs: BridgeInputs, beam_layout_obj, beam_rail_obj):
        stage_start = inputs.bridge_info.stage_start
        stg_line_lt = inputs.bridge_info.stg_line_lt
        stg_line_rt = inputs.bridge_info.stg_line_rt
        n_beams = inputs.bridge_info.n_beams
        beam_spa = inputs.bridge_info.beam_spa
        ws = inputs.bridge_info.ws
        cant_len = beam_layout_obj.cant_len
        beam_pos = beam_layout_obj.beam_pos
        beam_ht = beam_rail_obj.b_height
        A_beam = beam_rail_obj.area
        y_b_nc = beam_rail_obj.y_b_nc
        I_g_nc = beam_rail_obj.I_g_nc
        tf_width = beam_rail_obj.tf_width
        rail_wt = beam_rail_obj.r_weight
        "New Definitions"
        self.over_deck_t = inputs.bridge_info.deck_thick + inputs.bridge_info.sacrificial_ws
        self.min_haunch = 1 / 12 + inputs.bridge_info.rdwy_slope * tf_width / 2
        self.deck_forms = 0.005
        self.drip_bead = 0.75 * 8 / 144 * 0.15 * beam_rail_obj.is_Open
        self.ex_bm_ar = np.array([1 if i == 0 or i == n_beams - 1 else 0 for i in range(n_beams)])
        self.deck_E_c = 120000 * 0.975 * 0.145 ** 2 * 4 ** 0.33
        self.n_deck = self.deck_E_c / beam_rail_obj.E_c

        self._calc_stage_widths(stage_start, stg_line_rt, stg_line_lt, beam_spa, beam_pos, cant_len, n_beams)
        self._calc_deck_sections(beam_ht, A_beam, y_b_nc, I_g_nc)
        self.dist_dead_load(tf_width, rail_wt, beam_spa, ws = inputs.bridge_info.ws)

    def _calc_stage_widths(self, stage_start, stg_line_rt, stg_line_lt, beam_spa, beam_pos, cant_len, n_beams):
        stage_1, stage_2, trib_width_1, trib_width_2 = [np.zeros(n_beams) for _ in range(4)]
        if inputs.bridge_info.staged == 'yes':
            left_cond = (beam_pos <= stg_line_lt) & (stage_start == 'left')
            right_cond = (beam_pos >= stg_line_rt) & (stage_start == 'left')

            stage_1[left_cond] = stage_2[right_cond] = 1

            for i in range(n_beams):
                if left_cond[i] or right_cond[i]:
                    #### PICK STAGE LINE ####
                    line = stg_line_lt if left_cond[i] else stg_line_rt
                    #### PICK TRIBUTARY WIDTH ARRAY ####
                    arr = trib_width_1 if left_cond[i] else trib_width_2

                    if (left_cond[i] and beam_pos[i] + beam_spa / 2 > line) or (right_cond[i] and beam_pos[i] - beam_spa / 2 < line):
                        arr[i] = beam_pos[i] - beam_pos[i-1] + abs(beam_pos[i] - line) - beam_spa / 2
                    elif i == 0:
                        arr[i] = beam_pos[i] + beam_spa / 2
                    elif i == n_beams - 1 and right_cond[i]:
                        arr[i] = beam_pos[i] - beam_pos[i-1] - beam_spa / 2 + cant_len
                    else:
                        arr[i] = beam_pos[i] - beam_pos[i-1]
        else:
          stage_1 = np.ones(n_beams)
          trib_width_1 = np.where((np.arange(n_beams) == 0) | (np.arange(n_beams) == n_beams - 1),
                        cant_len + beam_spa / 2, beam_spa)

        stage_3 = stage_1 + stage_2
        trib_width_3 = np.where((np.arange(n_beams) == 0) | (np.arange(n_beams) == n_beams - 1),
                        cant_len + beam_spa / 2, beam_spa)

        self.deck = {
            'Stage 1 Width': trib_width_1,
            'Stage 2 Width': trib_width_2,
            'Stage 3 Width': trib_width_3
        }

        self.stage_1, self.stage_2, self.stage_3 = stage_1, stage_2, stage_3
        self.deck_df = pd.DataFrame(self.deck)

        return self

    def _calc_deck_sections(self, beam_ht, A_beam, y_b_nc, I_g_nc):
        over_deck_t = self.over_deck_t
        n_deck = self.n_deck
        deck_df = self.deck_df

        #### (A_beam * y_beam + A_deck * n * y_deck) / (A_beam + A_deck * n)
        deck_df['y_b_c Stage 1'] = (A_beam * y_b_nc + \
            over_deck_t * deck_df['Stage 1 Width'] * 12 * n_deck * (over_deck_t /2 + beam_ht)) \
            / (A_beam + over_deck_t * n_deck * deck_df['Stage 1 Width'] * 12)

        deck_df['y_b_c Stage 2'] = (A_beam * y_b_nc + \
            over_deck_t * deck_df['Stage 2 Width'] * 12 * n_deck * (over_deck_t /2 + beam_ht)) \
            / (A_beam + over_deck_t * n_deck * deck_df['Stage 2 Width'] * 12)

        deck_df['y_b_c Stage 3'] = (A_beam * y_b_nc + \
            over_deck_t * deck_df['Stage 3 Width'] * 12 * n_deck * (over_deck_t /2 + beam_ht)) \
            / (A_beam + over_deck_t * n_deck * deck_df['Stage 3 Width'] * 12)

        #### I_deck * n + A_deck * n * (y_deck - y_cen)^2 + I_beam + A_beam * (y_beam - y_cen)^2
        deck_df['I_c Stage 1'] = deck_df['Stage 1 Width'] * 12 * over_deck_t ** 3 * n_deck / 12 + \
            deck_df['Stage 1 Width'] * 12 * over_deck_t * n_deck * (over_deck_t /2 + beam_ht - deck_df['y_b_c Stage 1']) ** 2 + \
            I_g_nc * self.stage_1 + A_beam * (y_b_nc - deck_df['y_b_c Stage 1']) ** 2

        deck_df['I_c Stage 2'] = deck_df['Stage 2 Width'] * 12 * over_deck_t ** 3 * n_deck / 12 + \
            deck_df['Stage 2 Width'] * 12 * over_deck_t * n_deck * (over_deck_t /2 + beam_ht - deck_df['y_b_c Stage 2']) ** 2 + \
            I_g_nc * self.stage_2 + A_beam * (y_b_nc - deck_df['y_b_c Stage 2']) ** 2

        deck_df['I_c Stage 3'] = deck_df['Stage 3 Width'] * 12 * over_deck_t ** 3 * n_deck / 12 + \
            deck_df['Stage 3 Width'] * 12 * over_deck_t * n_deck * (over_deck_t /2 + beam_ht - deck_df['y_b_c Stage 3']) ** 2 + \
            I_g_nc + A_beam * (y_b_nc - deck_df['y_b_c Stage 3']) ** 2

        self.deck_df = deck_df

        return self

    def dist_dead_load(self, tf_width, rail_wt, beam_spa, ws):
        over_deck_t, min_haunch, deck_df = self.over_deck_t, self.min_haunch, self.deck_df
        stage_1, stage_2, trib_width_1, trib_width_2 = self.stage_1, self.stage_2, self.deck['Stage 1 Width'], self.deck['Stage 2 Width']

        #### STAGE 1 NONCOMPOSITE AND COMPOSITE WEIGHTS ####
        comp_dist_1 = deck_df['Stage 1 Width'] / deck_df['Stage 1 Width'].sum()
        deck_df['Stage 1 NC Wt'] = 0.15 * over_deck_t / 12 * deck_df['Stage 1 Width'] + \
            (0.15 * tf_width * min_haunch + (deck_df['Stage 1 Width'] - tf_width) * self.deck_forms) * stage_1 + self.drip_bead * self.ex_bm_ar * stage_1
        deck_df['Stage 1 C Wt'] = rail_wt * comp_dist_1

        #### STAGE 2 NONCOMPOSITE AND COMPOSITE WEIGHTS ####
        comp_dist_2 = deck_df['Stage 2 Width'] / deck_df['Stage 2 Width'].sum()
        deck_df['Stage 2 NC Wt'] = 0.15 * over_deck_t / 12 * deck_df['Stage 2 Width'] + \
            (0.15 * tf_width * min_haunch + (deck_df['Stage 2 Width'] - tf_width) * self.deck_forms) * stage_2 + self.drip_bead * self.ex_bm_ar * stage_2
        deck_df['Stage 2 C Wt'] = rail_wt * comp_dist_2

        #### STAGE 3 NONCOMPOSITE WEIGHT ####
        self.closure_width = (deck_df['Stage 3 Width'] - deck_df['Stage 2 Width'] - deck_df['Stage 1 Width'])
        self.closure_over_beam_flange = np.where((trib_width_1 + trib_width_2) > (beam_spa + tf_width) / 2, 0, \
            (beam_spa + tf_width) / 2 - (trib_width_1 + trib_width_2))
        clos_stage_1 = (self.closure_width.sum() - self.closure_over_beam_flange.sum()) / 2 + (self.closure_over_beam_flange * stage_1).sum()
        clos_stage_2 = (self.closure_width.sum() - self.closure_over_beam_flange.sum()) / 2 + (self.closure_over_beam_flange * stage_2).sum()
        dist_width_closure_1 = stage_1 / stage_1.sum()
        dist_width_closure_2 = stage_2 / stage_2.sum()
        dist_width_closure = dist_width_closure_1 * clos_stage_1 + dist_width_closure_2 * clos_stage_2
        deck_df['Stage 3 PC Wt'] = 0.15 * dist_width_closure * over_deck_t / 12 + self.closure_width * self.deck_forms

        #### STAGE 3 COMPOSITE WEIGHT ####
        ws_width = deck_df['Stage 3 Width'].copy()
        ws_width.iloc[0] -= 1
        ws_width.iloc[-1] -= 1
        deck_df['Stage 3 C Wt'] = ws * ws_width

        self.deck_df = deck_df

        return self

class PrestressingCamberCalculator:
    def __init__(self, inputs: BridgeInputs, beam_rail_obj, beam_layout_obj, stations_obj, IL: float = 0.1, TL: float = 0.2):
        #### MATERIAL PROPERTIES AND PRESTRESSING PARAMETERS ####
        beam_ht = beam_rail_obj.b_height
        y_b_nc = beam_rail_obj.y_b_nc
        E_c_i = beam_rail_obj.E_c_i
        I_g_nc = beam_rail_obj.I_g_nc
        L_beam = beam_layout_obj.L_beam
        ns = beam_layout_obj.ns

        if beam_rail_obj.is_NU == True:
            self.A_strand = 0.217
        else:
            self.A_strand = 0.167
        self.E_ps = 28500
        self.f_pu = 270
        self.f_pei = 0.75 * self.f_pu * (1 - IL)  # Initial effective prestress
        self.f_pe = 0.75 * self.f_pu * (1 - TL)   # Final effective prestress
        sta_G = stations_obj.sta_G
        s = stations_obj.s
        L_span_gen = stations_obj.L_span_gen
        span_configs = inputs.span_configs

        self._calculate_total_camber(span_configs, ns, s, L_span_gen, L_beam, sta_G, beam_ht, y_b_nc, E_c_i, I_g_nc)

    def validate_inputs(self, span_config: Dict, L_beam) -> None:
        #### INPUT VALIDATION CHECKS ####
        straight_strands = np.array(span_config.straight_strands)

        # Check debonding configurations if present
        if span_config.debond_config:
            for debond in span_config.debond_config:
                row_idx = debond.row - 1  # Convert to 0-based indexing
                total_debonded = sum(debond.strands)
                total_in_row = straight_strands[row_idx] / self.A_strand

                # Check debonded strands don't exceed 45% of row
                if total_debonded / total_in_row > 0.45:
                    raise ValueError(f"Debonded strands in row {debond.row} exceed 45% limit")

                # Check debonding lengths don't exceed 20% of beam length
                for length in debond.lengths:
                    if length > 0.2 * L_beam:
                        raise ValueError(f"Debonding length {length} ft exceeds 20% of beam length")

    def calculate_strand_eccentricity(self, d_ps: np.ndarray, beam_ht, y_b_nc):
        return d_ps - (beam_ht - y_b_nc)

    def calculate_straight_strand_camber(self, A_ps: np.ndarray, e_ps: np.ndarray, L_beam, E_c_i, I_g_nc) -> float:
        return np.sum(A_ps * self.f_pei * e_ps) * (L_beam * 12) ** 2 / (8 * E_c_i * I_g_nc)

    def calculate_debonded_strand_camber(self, debond_config: List[Dict], d_ps: np.ndarray, e_ps: np.ndarray, L_beam, E_c_i, I_g_nc) -> float:
        #### DEBONDED STRAND CAMBER CALCULATION ####
        total_camber = 0.0
        for debond in debond_config:
            row_idx = debond.row - 1  # Convert to 0-based indexing
            strands_list = debond.strands
            lengths_list = debond.lengths
            # Calculate contribution for each debonding length group in this row
            for strands, length in zip(strands_list, lengths_list):
                A_debond = strands * self.A_strand
                P_debond = A_debond * self.f_pei
                # Debonding factor from PCI Design Handbook
                debond_factor = 1 - 2 * (length / L_beam) ** 2 - 2 * (length / L_beam) ** 2
                camber_contribution = (P_debond * e_ps[row_idx] * debond_factor * (L_beam * 12) ** 2) / (8 * E_c_i * I_g_nc)
                total_camber += camber_contribution
        return total_camber

    def calculate_harped_strand_camber(self, harp_config: Dict, d_ps: np.ndarray, e_ps: np.ndarray, L_beam, E_c_i, I_g_nc) -> float:
        #### HARPED STRAND CAMBER CALCULATION ####
        harped_strands = np.array(harp_config.strands)
        harped_depth = np.array(harp_config.harped_depths)
        harping_length = harp_config.harping_length_factor * L_beam

        A_harp = harped_strands * self.A_strand
        P_harp = A_harp * self.f_pei
        y_ps_harped = d_ps - harped_depth

        # PCI Design Handbook formula for harped strands
        term1 = e_ps * (L_beam * 12) ** 2 / 8
        term2 = y_ps_harped * (harping_length * 12) ** 2 / 6

        return np.sum(P_harp * (term1 - term2)) / E_c_i / I_g_nc

    def distribute_camber_parabolic(self, camber_midspan: float, L_beam, L_x) -> np.ndarray:
        #### PARABOLIC CAMBER DISTRIBUTION ####
        # PCI Design Handbook: yc = yc_mid * (1 - ((L/2 - x)/(L/2))^2)
        return camber_midspan * (1 - ((L_beam/2 - L_x) / (L_beam/2)) ** 2)

    def calculate_span_camber(self, span_config: Dict, beam_ht, y_b_nc, L_beam, L_x, E_c_i, I_g_nc) -> np.ndarray:
        #### VALIDATE INPUTS ####
        self.validate_inputs(span_config, L_beam)
        #### SETUP STRAND GEOMETRY ####
        if span_config.harp_config:
            harped_strands = np.array(span_config.harp_config.strands)
        if span_config.debond_config:
            total_debonded = 0
            for debond in span_config.debond_config:
                row_idx = debond.row - 1  # Convert to 0-based indexing
                strands_list = debond.strands
                lengths_list = debond.lengths
                # Calculate contribution for each debonding length group in this row
                for strands, length in zip(strands_list, lengths_list):
                    debonded_strands = np.zeros_like(span_config.straight_strands)
                    debonded_strands[row_idx] = strands
                    total_debonded += debonded_strands
        straight_strands = np.array(span_config.straight_strands - harped_strands - total_debonded) * self.A_strand
        straight_strands[straight_strands < 0] = 0
        d_ps_base = beam_ht - np.array(span_config.strand_dist_bot)
        e_ps = self.calculate_strand_eccentricity(d_ps_base, beam_ht, y_b_nc)

        #### CALCULATE CAMBER COMPONENTS ####
        camber_total = 0.0

        # Straight bonded strands
        camber_straight = self.calculate_straight_strand_camber(straight_strands, e_ps, L_beam, E_c_i, I_g_nc)
        camber_total += camber_straight

        # Debonded strands
        if span_config.debond_config:
            camber_debonded = self.calculate_debonded_strand_camber(span_config.debond_config, d_ps_base, e_ps, L_beam, E_c_i, I_g_nc)
            camber_total += camber_debonded


        # Harped strands
        if span_config.harp_config:
            camber_harped = self.calculate_harped_strand_camber(span_config.harp_config, d_ps_base, e_ps, L_beam, E_c_i, I_g_nc)
            camber_total += camber_harped

        #### DISTRIBUTE CAMBER ALONG SPAN ####
        return self.distribute_camber_parabolic(camber_total, L_beam, L_x)

    def _calculate_total_camber(self, span_configs: List[Dict], ns, s, L_span_gen, L_beam, sta_G, beam_ht, y_b_nc, E_c_i, I_g_nc) -> np.ndarray:
        #### INITIALIZE CAMBER ARRAY ####
        self.camber = np.zeros_like(sta_G)

        #### CALCULATE CAMBER FOR EACH SPAN ####
        for i in range(ns):
            # Determine station indices for this span
            start_index = int(s[:i].sum()) if i > 0 else 0
            end_index = int(s[:i+1].sum())
            L_x = L_span_gen[start_index:end_index] + 0.5

            # Calculate camber for this span
            span_camber = self.calculate_span_camber(span_configs[i], beam_ht, y_b_nc, L_beam[i], L_x, E_c_i, I_g_nc)

            # Assign to total camber array
            self.camber[start_index:end_index, :] = span_camber

        return self

def gauss(f, a, b, m):
    chi = np.array([-np.sqrt(3/5), 0, np.sqrt(3/5)])
    w = np.array([5/9, 8/9, 5/9])
    h = (b-a)/m # creates a (# x points, # girder lines) matrix

    # Create arrays for all intervals at once
    i_vals = np.arange(m) # creates an m x 1 matrix
    # Create a_temps matrix with shape (# x points, # girder lines, 1, m) by expanding dimensions of a, h, and i_vals for broadcasting
    a_temps = a[:, :, np.newaxis, np.newaxis] + i_vals[np.newaxis, np.newaxis, np.newaxis, :] * h[:, :, np.newaxis, np.newaxis]
    b_temps = a[:, :, np.newaxis, np.newaxis] + (i_vals[np.newaxis, np.newaxis, np.newaxis, :] + 1) * h[:, :, np.newaxis, np.newaxis]

    # Jacobian for each interval
    J_vals = (b_temps - a_temps) / 2 # create an (# x points, # girder lines, 1, m) matrix of the Jacobian

    # Compute x values for all intervals and quadrature points simultaneously
    x_matrix = ((b_temps - a_temps) / 2 * chi[np.newaxis, np.newaxis, :, np.newaxis] + (b_temps + a_temps) / 2)  # create a (# x points, # girder lines, # gauss points, m) matrix

    # Evaluate function at all points (vectorized if f supports it)
    f_matrix = f(x_matrix) # needs to be able to utilize original inputs for "L" and "w" from initial inputs into function passed to gauss function

    # Apply Jacobian and weights, broadcast J_vals across len(chi) and w across len(b[1]), len(b[0]), :, i_vals
    weighted_matrix = f_matrix * J_vals * w[np.newaxis, np.newaxis, :, np.newaxis] # needs to multiply the weights across (# x points, # girder lines, # gauss points, m)

    # Sum over all intervals and quadrature points
    return np.sum(weighted_matrix, axis=(2, 3)) # needs to sum both weights and "m" values into a (# x points, # girder lines) matrix

def gauss_seidel(A, b, tol, max_iter=50):
  iter=0
  x0 = np.ones(A.shape[0])
  r = b - np.dot(A, x0)
  err0 = np.sum(np.abs(r))
  err = tol + 1
  x = x0
  while iter < max_iter and err > tol:
    iter += 1
    for i in range(A.shape[0]):
      if A[i, i] == 0:
        x[i] = 0
      else:
        x[i] = (b[i] - np.dot(A[i, :], x[:]) + A[i, i] * x[i]) / A[i, i]
    r = b - np.dot(A, x)
    if r.any() == 0:
      err = 0
    else:
      err = np.sum(np.abs(r))/err0
  return x

# Moment functions for structural analysis
uniform_M = lambda x, L, w: w / 2 * (x * L - x ** 2)
x_uniform_M = lambda x, L, w: x * uniform_M(x, L, w)
quad_inv_para_M = lambda x, L, w: w * (-x ** 3 / 6 / L + x ** 4 / 12 / L ** 2 + x * L / 12)
x_quad_inv_para_M = lambda x, L, w: x * quad_inv_para_M(x, L, w)
quad_para_M = lambda x, L, w: w * (-x ** 2 / 8 + x ** 3 / 6 / L - x ** 4 / 12 / L ** 2 + x * L / 24)
x_quad_para_M = lambda x, L, w: x * quad_para_M(x, L, w)

class simple_span:
    def __init__(self, inputs: BridgeInputs, beam_rail_obj, beam_layout_obj, stations_obj, deck_sections_obj):
        deck_df = deck_sections_obj.deck_df
        s = stations_obj.s
        sta_G = stations_obj.sta_G
        L_span_gen = stations_obj.L_span_gen
        ns = beam_layout_obj.ns
        L_beam = beam_layout_obj.L_beam
        L_brg_brg = beam_layout_obj.L_brg_brg
        E_c = beam_rail_obj.E_c
        E_c_i = beam_rail_obj.E_c_i
        I_g_nc = beam_rail_obj.I_g_nc
        beam_wt = beam_rail_obj.b_weight
        bm_lines = beam_rail_obj.no_long_lines
        "Initialize Section Properties"
        self.E_c_i = np.ones((int(s.sum()), bm_lines)) * beam_rail_obj.E_c_i
        self.E_c = np.ones((int(s.sum()), bm_lines)) * beam_rail_obj.E_c
        self.I_g_NC = np.ones((int(s.sum()), bm_lines)) * beam_rail_obj.I_g_nc
        self.I_g_C_S1_S2 = np.ones((int(s.sum()), bm_lines)) * np.array(np.repeat(deck_df['I_c Stage 1'] + deck_df['I_c Stage 2'], 2))
        self.I_g_C_S3 = np.ones((int(s.sum()), bm_lines))  * np.array(np.repeat(deck_df['I_c Stage 3'], 2))
        "Initialize Dead Loads"
        self.w_NC_S1_S2 = np.array(np.repeat(deck_df['Stage 1 NC Wt'] + deck_df['Stage 2 NC Wt'], 2))[np.newaxis, :, np.newaxis, np.newaxis]
        self.w_C_S1_S2 = np.array(np.repeat(deck_df['Stage 1 C Wt'] + deck_df['Stage 2 C Wt'], 2))[np.newaxis, :, np.newaxis, np.newaxis]
        self.w_PC_S3 = np.array(np.repeat(deck_df['Stage 3 PC Wt'], 2))[np.newaxis, :, np.newaxis, np.newaxis]
        self.w_C_S3 = np.array(np.repeat(deck_df['Stage 3 C Wt'], 2))[np.newaxis, :, np.newaxis, np.newaxis]

        self._calc_deflections(s, ns, L_span_gen, L_beam, L_brg_brg, beam_wt, bm_lines, E_c, E_c_i, I_g_nc)

    "defl = aA / EI"
    "aA = x / L * ( L * gauss M(L) - gauss xM(L) ) - (x * gauss M(x) - gauss xM(x) )"
    def calc_aA(span, function_1, function_2, L_span, L_x, m):
        return ((L_span * gauss(function_1, np.zeros_like(L_x), L_span, m) -
                gauss(function_2, np.zeros_like(L_x), L_span, m)) * L_x / L_span -
                (L_x * gauss(function_1, np.zeros_like(L_x), L_x, m) -
                gauss(function_2, np.zeros_like(L_x), L_x, m)))

    def _calc_deflections(self, s, ns, L_span_gen, L_beam, L_brg_brg, beam_wt, bm_lines, E_c, E_c_i, I_g_nc):
        results = [[], [], [], [], []]
        for i in range(ns):
            start_idx, end_idx = (int(s[:i].sum()) if i > 0 else 0), int(s[:i+1].sum())
            L_brg_x = L_span_gen[start_idx:end_idx]

            results[0].append(simple_span.calc_aA(i, lambda x: uniform_M(x, L_beam[i], beam_wt), lambda x: x_uniform_M(x, L_beam[i], beam_wt), L_beam[i], L_brg_x + 0.5, 1))
            for j, w in enumerate([self.w_NC_S1_S2, self.w_C_S1_S2, self.w_PC_S3, self.w_C_S3]):
                results[j+1].append(simple_span.calc_aA(i, lambda x: uniform_M(x, L_brg_brg[i], w), lambda x: x_uniform_M(x, L_brg_brg[i], w), L_brg_brg[i], L_brg_x, 1))

        # Convert to deflections
        factor = 12 ** 3 / E_c
        self.defl_self_wt = np.concatenate(results[0]) * 12 ** 3 / E_c_i / I_g_nc
        self.defl_NC_S1_S2 = np.concatenate(results[1]) * factor / I_g_nc
        self.defl_C_S1_S2_in, self.defl_PC_S3_in = [np.concatenate(results[i]) * factor / self.I_g_C_S1_S2 for i in [2,3]]
        self.defl_C_S3_in = np.concatenate(results[4]) * factor / self.I_g_C_S3

        return self

class continuous_deflections:
    def __init__(self, inputs, beam_rail_obj, beam_layout_obj, stations_obj, deck_sections_obj, defl_obj):
        #### INITIALIZE MATRICES ####
        self.n_sub = len(inputs.substructure.sta_CL_sub)
        bm_lines = beam_rail_obj.no_long_lines
        ns = beam_layout_obj.ns
        s = stations_obj.s
        L_span_gen = stations_obj.L_span_gen
        L_brg_brg = beam_layout_obj.L_brg_brg
        deck_df = deck_sections_obj.deck_df

        self.E_c_span = np.ones((ns, bm_lines)) * beam_rail_obj.E_c
        self._calc_3_moment_method_defl(bm_lines, ns, s, deck_df, L_brg_brg, L_span_gen, defl_obj)

    #### THREE-MOMENT METHOD OF COMPUTING INTERIOR SUPPORT MOMENTS FOR CONTINUOUS SPANS
    def calc_b(self, w, I_g_span, i, bm_lines):
        return -6 * sum((self.L_span[i + j] * gauss(lambda x: uniform_M(x, self.L_span[i + j], w / 12), np.zeros((1, bm_lines)), self.L_span[i + j], 1).flatten() -
                     gauss(lambda x: x_uniform_M(x, self.L_span[i + j], w / 12), np.zeros((1, bm_lines)), self.L_span[i + j], 1).flatten()) /
                    (self.E_c_span[i + j, :] * I_g_span[i + j, :] * self.L_span[i + j]) for j in range(2))

    def calc_stiff(self, I_g_span, j, diff):
        if diff in [-1, 1]: return self.L_span[j] / self.E_c_span[j, :] / I_g_span[j, :]
        elif diff == 0: return 2 * self.L_span[j] / self.E_c_span[j, :] / I_g_span[j, :] + 2 * self.L_span[j + 1] / self.E_c_span[j + 1, :] / I_g_span[j + 1, :]
        else: return 0

    def calc_defl(self, M_matrix, I_g_span, i, L_brg_span):
        return -(M_matrix[i, :] * (L_brg_span ** 2 / 2 - L_brg_span ** 3 / 6 / self.L_span[i] - self.L_span[i] * L_brg_span / 3) +
             M_matrix[i + 1, :] * (L_brg_span ** 3 / 6 / self.L_span[i] - self.L_span[i] * L_brg_span / 6)) / (self.E_c_span[i, :] * I_g_span[i, :])

    def _calc_3_moment_method_defl(self, bm_lines, ns, s, deck_df, L_brg_brg, L_span_gen, defl_obj):
        if self.n_sub > 2:
            #### INITIALIZE MATRICES ####
            b_C_S1_S2, b_PC_S3, b_C_S3 = [np.zeros((self.n_sub - 2, bm_lines)) for _ in range(3)]
            C_S1_S2_rot_stiff, PC_S3_rot_stiff, C_S3_rot_stiff = [np.zeros((self.n_sub - 2, self.n_sub - 2, bm_lines)) for _ in range(3)]
            #### INITIALIZE AND DEFINE SPAN LENGTHS AND PROPERTIES ####
            self.L_span = np.zeros(ns)
            I_g_C_S1_S2_span, I_g_C_S3_span = [np.zeros((ns, bm_lines)) for _ in range(2)]
            self.L_span[:] = L_brg_brg * 12
            I_g_C_S1_S2_span[:] = np.repeat(deck_df['I_c Stage 1'] + deck_df['I_c Stage 2'], 2)
            I_g_C_S3_span[:] = np.repeat(deck_df['I_c Stage 3'], 2)
            #### CALCULATE "b" MATRICES ####
            for i in range(self.n_sub - 2):
                b_C_S1_S2[i, :] = self.calc_b(defl_obj.w_C_S1_S2, I_g_C_S1_S2_span, i, bm_lines)
                b_PC_S3[i, :] = self.calc_b(defl_obj.w_PC_S3, I_g_C_S1_S2_span, i, bm_lines)
                b_C_S3[i, :] = self.calc_b(defl_obj.w_C_S3, I_g_C_S3_span, i, bm_lines)
                for j in range(self.n_sub - 2):
                    C_S1_S2_rot_stiff[i, j] = self.calc_stiff(I_g_C_S1_S2_span, j, j - i)
                    PC_S3_rot_stiff[i, j] = self.calc_stiff(I_g_C_S1_S2_span, j, j - i)
                    C_S3_rot_stiff[i, j] = self.calc_stiff(I_g_C_S3_span, j, j - i)
            #### INITIALIZE INTERNAL MOMENT MATRICES ####
            M_C_S1_S2, M_PC_S3, M_C_S3 = [np.zeros_like(b) for b in [b_C_S1_S2, b_PC_S3, b_C_S3]]
            #### SOLVE Ax = b WITH GAUSS-SEIDEL #### (guaranteed to converge when "A" is diagonally dominant by rows)
            for i in range(bm_lines):
                M_C_S1_S2[:, i], M_PC_S3[:, i], M_C_S3[:, i] = [gauss_seidel(A[:, :, i], b[:, i], 1e-6) for A, b in [(C_S1_S2_rot_stiff, b_C_S1_S2), (PC_S3_rot_stiff, b_PC_S3), (C_S3_rot_stiff, b_C_S3)]]
            #### ZERO MOMENTS AT PINNED SUPPORTS AND INITIALIZE DEFLECTIONS ####
            add_zeros = np.zeros((1, bm_lines))
            M_C_S1_S2, M_PC_S3, M_C_S3 = [np.concatenate((add_zeros, M, add_zeros), axis = 0) for M in [M_C_S1_S2, M_PC_S3, M_C_S3]]
            add_M_defl_C_S1_S2_i, add_M_defl_PC_S3_i, add_M_defl_C_S3_i = [], [], []
            #### COMPUTE DEFLECTIONS FROM ONLY INTERNAL MOMENTS ####
            for i in range(ns):
                start_index, L_brg_span = (0, L_span_gen[:int(s[0].sum())] * 12) if i == 0 else (int(s[:i].sum()), L_span_gen[int(s[:i].sum()):int(s[:i + 1].sum())] * 12)
                for defl_list, M_matrix, I_g_span in [(add_M_defl_C_S1_S2_i, M_C_S1_S2, I_g_C_S1_S2_span), (add_M_defl_PC_S3_i, M_PC_S3, I_g_C_S1_S2_span), (add_M_defl_C_S3_i, M_C_S3, I_g_C_S3_span)]:
                    defl_list.append(self.calc_defl(M_matrix, I_g_span, i, L_brg_span))
        else:
            add_M_defl_C_S1_S2_i, add_M_defl_PC_S3_i, add_M_defl_C_S3_i = [0], [0], [0]
        #### SUM DEFLECTIONS FROM INTERNAL MOMENTS WITH SIMPLE SPAN MOMENTS ####
        defl_obj.defl_C_S1_S2 = np.concatenate(add_M_defl_C_S1_S2_i, axis = 0) + defl_obj.defl_C_S1_S2_in
        defl_obj.defl_PC_S3 = np.concatenate(add_M_defl_PC_S3_i, axis = 0) + defl_obj.defl_PC_S3_in
        defl_obj.defl_C_S3 = np.concatenate(add_M_defl_C_S3_i, axis = 0) + defl_obj.defl_C_S3_in
        return defl_obj

class variable_haunch:
    def __init__(self, inputs: BridgeInputs, vc_obj, beam_rail_obj, beam_layout_obj, stations_obj, deck_sections_obj, prestress_obj, defl_obj):
        d = defl_obj
        rdwy_slope = inputs.bridge_info.rdwy_slope
        skew = inputs.bridge_info.skew
        bm_lines = beam_rail_obj.no_long_lines
        tf_width = beam_rail_obj.tf_width
        I_g_nc = beam_rail_obj.I_g_nc
        E_c = beam_rail_obj.E_c
        off = beam_layout_obj.off
        offsets = beam_layout_obj.offsets
        ns = beam_layout_obj.ns
        L_brg_brg = beam_layout_obj.L_brg_brg
        s = stations_obj.s
        sta_x_10_ft = stations_obj.sta_x_10_ft
        sta_G = stations_obj.sta_G
        L_span_gen = stations_obj.L_span_gen
        camber = prestress_obj.camber

        "Top of Slab Grade Elevations"
        self.TS_Elev = VerticalCurve.elev(vc_obj, sta_G) - abs(offsets) * rdwy_slope

        "New Variables used in rest of calculation"
        self.check_control_haunch = np.zeros((ns, bm_lines))
        self.w_hnch = np.zeros((ns, bm_lines))
        self.var_haunch_i = np.ones((int(s.sum()), bm_lines))
        self.defl_var_haunch = np.zeros((int(s.sum()), bm_lines))
        self.iter = 0

        "Calculate Deflections from Roadway Profile and Haunches"
        self._profile_deflections(vc_obj, rdwy_slope, skew, bm_lines, off, ns, s, sta_x_10_ft, sta_G)
        self._adjust_defl_ends_to_brg(d, ns, s, camber)
        self._calc_haunch_ht(d, tf_width, ns, L_brg_brg, L_span_gen, s, E_c, I_g_nc)

    def _profile_deflections(self, vc_obj, rdwy_slope, skew, bm_lines, off, ns, s, sta_x_10_ft, sta_G):
        self.profile_deflections = np.zeros((int(s.sum()), bm_lines))
        for i in range(ns):
            start, end = int(s[:i].sum()) if i > 0 else 0, int(s[:i+1].sum())
            #### THE REDUCTION BY 1 IS NEEDED FOR CORRECT INDEXING ####
            slope = (self.TS_Elev[start] - self.TS_Elev[end - 1]) / (sta_G[start] - sta_G[end - 1])
            self.profile_deflections[start:end] = self.TS_Elev[start:end] - (slope * (sta_G[start:end] - sta_G[start]) + self.TS_Elev[start])

        #### ADJUST END ELEVATIONS FOR CL BEARING ####
        first_last_indices = np.concatenate([np.array([int(s[:i].sum()) if i > 0 else 0, int(s[:i+1].sum()) - 1]) for i in range(ns)])
        sta_G[first_last_indices, :] = sta_x_10_ft[first_last_indices] + off * np.tan(np.deg2rad(skew))
        self.TS_Elev[first_last_indices, :] = VerticalCurve.elev(vc_obj, sta_G[first_last_indices, :]) - rdwy_slope * abs(off)
        return self

    def _adjust_defl_ends_to_brg(self, d, ns, s, camber):
    #### ADJUST DEFLECTIONS TO START AT THE BRG CENTERLINE ####
        self.camber_adj = np.zeros_like(camber)
        self.defl_self_wt_adj = np.zeros_like(d.defl_self_wt)
        for i in range(ns):
            start_index = int(s[:i].sum()) if i > 0 else 0
            end_index = int(s[:i+1].sum())
            self.camber_adj[start_index:end_index] = camber[start_index:end_index] - camber[start_index]
            self.defl_self_wt_adj[start_index:end_index, :] = d.defl_self_wt[start_index:end_index, :] - d.defl_self_wt[start_index, :]
        return self

    def _calc_haunch_ht(self, d, tf_width, ns, L_brg_brg, L_span_gen, s, E_c, I_g_nc):
        self.defl_final = 1.3 * (1.8 * self.camber_adj - 1.85 * self.defl_self_wt_adj) - (d.defl_NC_S1_S2 + d.defl_PC_S3) - (d.defl_C_S1_S2 + d.defl_C_S3)
        while self.iter < 50:

            #### INITIALIZE FOR EACH ITERATION ####
            self.iter += 1
            aA_moment_var_haunch = []

            #### DEFINE OLD HAUNCH ####
            var_haunch_prev = self.var_haunch_i.copy()

            for i in range(ns):
                start_index = int(s[:i].sum()) if i > 0 else 0
                end_index = int(s[:i+1].sum())
                L_brg_x = L_span_gen[start_index:end_index]

                #### SIMPLIFY TERMS, FINAL DEFLECTIONS ADJUSTED FOR OLD HAUNCH DEFLECTIONS ####
                pro_defl = self.profile_deflections[start_index:end_index, :]
                fin_defl = (self.defl_final[start_index:end_index, :] - self.defl_var_haunch[start_index:end_index, :]) / 12

                #### CALCULATE MAX DEFLECTION FROM PROFILE AND TOTAL CAMBER ####
                max_pro_defl = np.max(pro_defl, axis = 0)
                max_fin_defl = np.max(fin_defl, axis = 0)

                #### CALCULATE NEW HAUNCHES BASED ON OLD DEFLECTIONS ####
                haunch_thickness = np.where(max_pro_defl > max_fin_defl, pro_defl - fin_defl, (max_fin_defl - max_pro_defl)[np.newaxis, :] + pro_defl - fin_defl)
                self.var_haunch_i[start_index:end_index, :] = haunch_thickness

                #### CALCULATE SHAPE OF NEW HAUNCH WEIGHT ON BEAM ####
                self.check_control_haunch[i, :] = np.where(max_pro_defl > max_fin_defl, 1, 0)
                self.w_hnch[i, :] = np.max(haunch_thickness, axis = 0) / 12 * tf_width * 0.15

                M_eq_var_haunch = lambda x: np.where(self.check_control_haunch[i, :] == 1,
                                         quad_inv_para_M(x, L_brg_brg[i], self.w_hnch[i,:]),
                                         quad_para_M(x, L_brg_brg[i], self.w_hnch[i,:]))
                xM_eq_var_haunch = lambda x: np.where(self.check_control_haunch[i, :] == 1,
                                         x_quad_inv_para_M(x, L_brg_brg[i], self.w_hnch[i,:]),
                                         x_quad_para_M(x, L_brg_brg[i], self.w_hnch[i,:]))

                #### CALCULATE NEW DEFLECTIONS FROM NEW HAUNCH WEIGHT ####
                aA_moment_var_haunch.append(simple_span.calc_aA(i, lambda x: M_eq_var_haunch(x), \
                                        lambda x: xM_eq_var_haunch(x), L_brg_brg[i], L_brg_x, 1))

            self.defl_var_haunch = np.concatenate(aA_moment_var_haunch) * 12 ** 3 / E_c / I_g_nc

            #### CALCULATE DIFFERENCE BETWEEN OLD AND NEW HAUNCH THICKNESSES ####
            max_change = np.max(np.abs(self.var_haunch_i - var_haunch_prev))
            #print(f"Iteration {self.iter}: Maximum haunch change = {max_change:.6f}")

            #### IF OLD HAUNCHES ARE NOT TOO DIFFERENT FROM NEW HAUNCHES, STOP ####
            if max_change < 0.0001:
              #print("Haunch Thickness Converged")
              self.defl_final = 1.3 * (1.8 * self.camber_adj - 1.85 * self.defl_self_wt_adj) - (d.defl_NC_S1_S2 + self.defl_var_haunch + d.defl_PC_S3) - (d.defl_C_S1_S2 + d.defl_C_S3)
              break

        #### IF NO CONVERGENCE #########################################################
        #if self.iter >= 50:

            #print(f"Warning: Maximum iterations reached. Final change: {max_change:.6f}")
        return self

class min_camber_check:
    def __init__(self, beam_rail_obj, beam_layout_obj, stations_obj, defl_obj, final_haunch_obj):
        d = defl_obj
        f = final_haunch_obj
        tf_width = beam_rail_obj.tf_width
        bm_lines = beam_rail_obj.no_long_lines
        E_c = beam_rail_obj.E_c
        I_g_nc = beam_rail_obj.I_g_nc
        ns = beam_layout_obj.ns
        s = stations_obj.s
        L_span_gen = stations_obj.L_span_gen
        L_brg_brg = beam_layout_obj.L_brg_brg
        self.min_camber_additional_haunch = np.zeros((ns, bm_lines))
        self.w_addl = np.zeros((ns, bm_lines))

        self._min_camber_check(d, f, tf_width, ns, L_brg_brg, s, L_span_gen, E_c, I_g_nc)

    def _min_camber_check(self, d, f, tf_width, ns, L_brg_brg, s, L_span_gen, E_c, I_g_nc):
        aA_moment_min_camb_check = []
        for i in range(ns):
            start_index = int(s[:i].sum()) if i > 0 else 0
            end_index = int(s[:i+1].sum())
            L_brg_x = L_span_gen[start_index:end_index]
            self.min_camber_additional_haunch[i, :] = 0.6 * np.max(1.8 * f.camber_adj[start_index:end_index, :] - 1.85 * f.defl_self_wt_adj[start_index:end_index, :])
            self.w_addl[i] = self.min_camber_additional_haunch[i, :] / 12 * tf_width * 0.15

            aA_moment_min_camb_check.append(simple_span.calc_aA(i, lambda x: quad_inv_para_M(x, L_brg_brg[i], self.w_addl[i]), \
                                          lambda x: x_quad_inv_para_M(x, L_brg_brg[i], self.w_addl[i]), L_brg_brg[i], L_brg_x, 1))

        self.defl_min_camb_check = np.concatenate(aA_moment_min_camb_check) * 12 ** 3 / E_c / I_g_nc

        #### CHECK WHETHER MINIMUM CAMBER RESULTS IN NET NEGATIVE CAMBER ####
        self.defl_check = 0.7 * (1.8 * f.camber_adj - 1.85 * f.defl_self_wt_adj) - (d.defl_NC_S1_S2 + d.defl_PC_S3) - (d.defl_C_S1_S2 + d.defl_C_S3) - self.defl_min_camb_check
        if self.defl_check.any() < 0:
            self.check = "Negative"
            #print("OVERALL DEFLECTION NEGATIVE, REVISE DESIGN")
        else:
            self.check = "Positive"
            #print("OVERALL DEFLECTION POSITIVE, GOOD DESIGN")
        return self

class seat_elev:
    def __init__(self, input: BridgeInputs, beam_rail_obj, beam_layout_obj, stations_obj, deck_sections_obj, final_haunch_obj, min_haunch_check_obj):
        f = final_haunch_obj
        m = min_haunch_check_obj
        bm_lines = beam_rail_obj.no_long_lines
        over_deck_t = deck_sections_obj.over_deck_t

        s = stations_obj.s
        L_span_gen = stations_obj.L_span_gen
        L_brg_brg = beam_layout_obj.L_brg_brg
        rdwy_slope = inputs.bridge_info.rdwy_slope
        ns = beam_layout_obj.ns
        offsets = beam_layout_obj.offsets
        tf_width = beam_rail_obj.tf_width
        beam_ht = beam_rail_obj.b_height

        self._calc_seat_elev(f, m, rdwy_slope, bm_lines, tf_width, beam_ht, ns, offsets, s, over_deck_t)

    def _calc_seat_elev(self, f, m, rdwy_slope, bm_lines, tf_width, beam_ht, ns, offsets, s, over_deck_t):
        self.min_haunch_GL = np.zeros((int(s.sum()), bm_lines))
        for j in range(bm_lines):
            self.min_haunch_GL[:, j] = 0 if ((offsets[0, j] < 0) == (j % 2 == 0)) else rdwy_slope * tf_width

        var_haunch = f.var_haunch_i + self.min_haunch_GL
        self.BS_Elev = f.TS_Elev - over_deck_t / 12
        self.Min_Haunch_Elev = self.BS_Elev - self.min_haunch_GL - 1 / 12
        self.TG_Elev = self.BS_Elev - var_haunch - 1 / 12
        self.TG_Check = self.TG_Elev - 0.6 * (1.8 * f.camber_adj - 1.85 * f.defl_self_wt_adj) / 12 - m.defl_min_camb_check / 12
        self.BG_Elev = self.TG_Elev - beam_ht / 12

        self.seat_elev = np.zeros((ns * 2, inputs.bridge_info.n_beams))

        for i in range(ns):
            start_index = int(s[:i].sum()) if i > 0 else 0
            end_index = int(s[:i+1].sum()) - 1
            sub = 'Abutment 1' if i == 0 else f'Pier {i}'
            sub_1 = 'Abutment 2' if i == ns - 1 else f'Pier {i+1}'
            for j in range(inputs.bridge_info.n_beams):
                self.seat_elev[2 * i, j] = np.min(self.BG_Elev[start_index, 2 * j:2 * j + 1]) - inputs.bridge_info.brg_thick
                self.seat_elev[2 * i + 1, j] = np.min(self.BG_Elev[end_index, 2 * j:2 * j + 1]) - inputs.bridge_info.brg_thick

        self.profile_tan_line = np.max(f.profile_deflections, axis = 0) - f.profile_deflections + f.TS_Elev

@dataclass
class AnalysisResults:
    """Container for all bridge analysis results"""
    vc_obj: object = field(default=None)              # Vertical curve geometry
    beam_rail_obj: object = field(default=None)       # Beam and railing properties
    beam_layout_obj: object = field(default=None)     # Beam positioning and layout
    stations_obj: object = field(default=None)        # Station locations along spans
    deck_sections_obj: object = field(default=None)   # Section properties and dead loads
    prestress_obj: object = field(default=None)       # Prestressing forces and camber
    defl_obj: object = field(default=None)            # Simple span deflections
    con_span_defl_calc: object = field(default=None)  # Continuous span deflections
    final_haunch_obj: object = field(default=None)    # Variable haunch calculations
    min_haunch_check_obj: object = field(default=None)# Minimum haunch verification
    seat_obj: object = field(default=None)            # Bearing seat elevations

def run_analysis(inputs):
    """
    Main bridge analysis function for prestressed concrete girder bridges
    Sequential analysis: geometry → properties → forces → deflections → haunch design
    """
    results = AnalysisResults()

    # Step 1: Establish vertical curve geometry (VPC/VPT stations and elevations)
    results.vc_obj = VerticalCurve(inputs)

    # Step 2: Define beam cross-section and railing properties
    results.beam_rail_obj = beam_rail_info(inputs)

    # Step 3: Calculate beam layout and positioning across deck width
    results.beam_layout_obj = beam_layout(inputs, results.beam_rail_obj)

    # Step 4: Generate station points for analysis along each span
    results.stations_obj = stations_locations(inputs, results.beam_layout_obj, results.beam_rail_obj)

    # Step 5: Calculate section properties and dead load effects
    results.deck_sections_obj = section_properties_dead_loads(inputs, results.beam_layout_obj, results.beam_rail_obj)

    # Step 6: Determine prestressing forces and initial camber
    results.prestress_obj = PrestressingCamberCalculator(inputs, results.beam_rail_obj, results.beam_layout_obj, results.stations_obj)

    # Step 7: Calculate simple span deflections under all loads
    results.defl_obj = simple_span(inputs, results.beam_rail_obj, results.beam_layout_obj, results.stations_obj, results.deck_sections_obj)

    # Step 8: Analyze continuous span behavior and deflections
    results.con_span_defl_calc = continuous_deflections(inputs, results.beam_rail_obj, results.beam_layout_obj, results.stations_obj, results.deck_sections_obj, results.defl_obj)

    # Step 9: Design variable haunch to achieve target profile
    results.final_haunch_obj = variable_haunch(inputs, results.vc_obj, results.beam_rail_obj, results.beam_layout_obj, results.stations_obj, results.deck_sections_obj, results.prestress_obj, results.defl_obj)

    # Step 10: Verify minimum haunch requirements
    results.min_haunch_check_obj = min_camber_check(results.beam_rail_obj, results.beam_layout_obj, results.stations_obj, results.defl_obj, results.final_haunch_obj)

    # Step 11: Calculate final bearing seat elevations
    results.seat_obj = seat_elev(inputs, results.beam_rail_obj, results.beam_layout_obj, results.stations_obj, results.deck_sections_obj, results.final_haunch_obj, results.min_haunch_check_obj)

    return results

results = run_analysis(inputs)

